package com.googlecode.mapperdao

import jdbc.Transaction
import org.springframework.jdbc.datasource.SingleConnectionDataSource
import java.util.Properties
import utils.Setup

/**
 * benchmark : an attempt to isolate and benchmark mapperdao
 *
 * @author kostantinos.kougios
 *
 *         9 Oct 2012
 */
object Benchmark extends App
{
	val database = "postgresql"
	val dataSource = singleConnectionDataSource
	val (jdbc, mapperDao, queryDao, txManager) = Setup.postGreSql(dataSource, List(ProductEntity, AttributeEntity))

	def p = Product(
		"test product",
		Set(
			Attribute("colour", "red"),
			Attribute("colour", "green"),
			Attribute("colour", "blue")
		)
	)

	val loops = args(0).toInt
	println("will run for %d loops".format(loops))

	println("warm up " + args(1))
	val method = args(1) match {
		case "insert" =>
			val m = benchmarkInsert _
			for (i <- 0 to 50) m(5)
			m
		case "select" =>
			val inserted = mapperDao.insert(ProductEntity, p)
			val m = benchmarkSelect(inserted.id, _: Int)
			m(500)
			m
		case "update" =>
			benchmarkUpdate(mapperDao.insert(ProductEntity, p), 500)
			benchmarkUpdate(mapperDao.insert(ProductEntity, p), _: Int)
	}

	println("benchmarking...")
	val start = System.currentTimeMillis
	method(loops)
	val stop = System.currentTimeMillis
	println("dt : " + (stop - start))

	/**
	 * History:
	 *
	 * date			loops			dt
	 * ------------------------------------
	 * 2013/03/20	10000			16261	laptop, in a transaction
	 * 2013/02/05	1000			5116
	 * 2013/02/05	10000			32800
	 * before		1000			11500
	 * before		10000			81300
	 *
	 */
	def benchmarkInsert(loops: Int) {
		val l = (for (i <- 1 to loops) yield p).toList
		Transaction.default(txManager) {
			() =>
				mapperDao.insertBatch(UpdateConfig.default, ProductEntity, l)
		}
	}

	def benchmarkSelect(id: Int, loops: Int) {
		for (i <- 0 to loops) {
			mapperDao.select(ProductEntity, id)
		}
	}

	def benchmarkUpdate(inserted: Product with SurrogateIntId, loops: Int) {
		var old = inserted
		for (i <- 0 to loops) {
			old = mapperDao.update(ProductEntity, old, p)
		}
	}

	case class Product(name: String, attributes: Set[Attribute])

	case class Attribute(name: String, value: String)

	object ProductEntity extends Entity[Int, SurrogateIntId, Product]
	{
		val id = key("id") sequence (database match {
			case "oracle" => Some("ProductSeq")
			case _ => None
		}) autogenerated (_.id)
		val name = column("name") to (_.name)
		val attributes = manytomany(AttributeEntity) getter ("attributes") to (_.attributes)

		def constructor(implicit m: ValuesMap) = new Product(name, attributes) with Stored
		{
			val id: Int = ProductEntity.id
		}
	}

	object AttributeEntity extends Entity[Int, SurrogateIntId, Attribute]
	{
		val id = key("id") sequence (database match {
			case "oracle" => Some("AttributeSeq")
			case _ => None
		}) autogenerated (_.id)
		val name = column("name") to (_.name)
		val value = column("value") to (_.value)
		val product = manytomanyreverse(ProductEntity) forQueryOnly() to (p => Nil)

		def constructor(implicit m: ValuesMap) = new Attribute(name, value) with Stored
		{
			val id: Int = AttributeEntity.id
		}
	}

	def singleConnectionDataSource = {
		val properties = loadJdbcProperties
		new SingleConnectionDataSource(
			properties.getProperty("url"),
			properties.getProperty("username"),
			properties.getProperty("password"), true)
	}

	def loadJdbcProperties = {
		val properties = new Properties
		properties.load(getClass.getResourceAsStream("/jdbc.benchmark.%s.properties".format(database)))
		properties
	}
}