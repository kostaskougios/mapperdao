package com.googlecode.mapperdao.state.persistcmds

import com.googlecode.mapperdao._
import utils.TraversableSeparation

/**
 * entities are converted to PersistOps
 *
 * @author kostantinos.kougios
 *
 *         21 Nov 2012
 */
class CmdPhase(typeManager: TypeManager) {

	private var alreadyProcessed = Map[Int, List[PersistCmd]]()

	def toInsertCmd[ID, T](
		entity: Entity[ID, _ <: DeclaredIds[ID], T],
		newVM: ValuesMap,
		updateConfig: UpdateConfig
	) = insert(entity.asInstanceOf[Entity[ID, DeclaredIds[ID], T]], newVM, true, updateConfig)

	def toUpdateCmd[ID, T](
		entity: Entity[ID, _ <: DeclaredIds[ID], T],
		oldValuesMap: ValuesMap,
		newValuesMap: ValuesMap,
		updateConfig: UpdateConfig
	) = update(entity.asInstanceOf[Entity[ID, DeclaredIds[ID], T]], oldValuesMap, newValuesMap, true, updateConfig)

	private def insert[ID, T](
		entity: Entity[ID, DeclaredIds[ID], T],
		newVM: ValuesMap,
		mainEntity: Boolean,
		updateConfig: UpdateConfig
	): List[PersistCmd] = {
		alreadyProcessed.get(newVM.identity) match {
			case None =>
				val tpe = entity.tpe
				val table = tpe.table
				val columnAndValues = newVM.toListOfSimpleColumnAndValueTuple(table.simpleTypeNotAutoGeneratedColumns)
				val op = InsertCmd(entity, newVM, columnAndValues, mainEntity) :: related(entity, None, newVM, updateConfig)
				alreadyProcessed += (newVM.identity -> op)
				op
			case Some(x) =>
				AlreadyProcessedCmd :: Nil
		}
	}

	private def update[ID, T](
		entity: Entity[ID, DeclaredIds[ID], T],
		oldVM: ValuesMap,
		newVM: ValuesMap,
		mainEntity: Boolean,
		updateConfig: UpdateConfig
	): List[PersistCmd] = {
		val op = alreadyProcessed.get(newVM.identity)
		if (op.isDefined) {
			AlreadyProcessedCmd :: Nil
		} else {
			val tpe = entity.tpe
			val table = tpe.table
			val newColumnAndValues = newVM.toListOfColumnAndValueTuple(table.simpleTypeNotAutoGeneratedColumns)
			val oldColumnAndValues = oldVM.toListOfColumnAndValueTuple(table.simpleTypeNotAutoGeneratedColumns)
			val changedColumnAndValues = (newColumnAndValues zip oldColumnAndValues) collect {
				case ((nc, nv), (oc, ov)) if (nv != ov) => (nc, nv)
			}
			val rel = related(entity, Some(oldVM), newVM, updateConfig)
			val op = UpdateCmd(entity, oldVM, newVM, changedColumnAndValues, mainEntity) :: rel
			alreadyProcessed += (newVM.identity -> op)
			op
		}
	}

	private def related[ID, T](
		entity: Entity[ID, DeclaredIds[ID], T],
		oldVMO: Option[ValuesMap],
		newVM: ValuesMap,
		updateConfig: UpdateConfig
	): List[PersistCmd] = {
		entity.tpe.table.relationshipColumnInfos(updateConfig.skip).map {
			/**
			 * ---------------------------------------------------------------------------------------------
			 * Many-To-Many
			 * ---------------------------------------------------------------------------------------------
			 */
			case ci@ColumnInfoTraversableManyToMany(column, columnToValue, getterMethod) =>
				val foreignEntity = column.foreign.entity
				foreignEntity match {
					/**
					 * ---------------------------------------------------------------------------------------------
					 * Many-To-Many : External entity
					 * ---------------------------------------------------------------------------------------------
					 */
					case foreignEE: ExternalEntity[_, _] =>
						if (oldVMO.isDefined) {
							// entity is updated
							val oldVM = oldVMO.get
							val oldT = oldVM.manyToMany(column)
							val newT = newVM.manyToMany(column)
							// we'll find what was added, intersect (stayed in the collection but might have been updated)
							// and removed from the collection
							val (added, intersect, removed) = TraversableSeparation.separate(foreignEntity, oldT, newT)

							val addedCmds = added.toList.map {
								fo =>
									InsertManyToManyExternalCmd(
										entity,
										foreignEE,
										ci,
										newVM,
										fo)
							}
							val intersectCmds = intersect.toList.map {
								case (oldO, newO) =>
									UpdateExternalCmd(foreignEE, ci, newO)
							}
							val removedCmds = removed.toList.map {
								ro =>
									DeleteManyToManyExternalCmd(entity, foreignEE, ci, newVM, ro)
							}
							addedCmds ::: intersectCmds ::: removedCmds
						} else {
							newVM.manyToMany(column).map {
								fo =>
									InsertManyToManyExternalCmd(
										entity,
										foreignEE,
										ci,
										newVM,
										fo)
							}
						}

					/**
					 * ---------------------------------------------------------------------------------------------
					 * Many-To-Many : Normal entity
					 * ---------------------------------------------------------------------------------------------
					 */
					case _ =>
						if (oldVMO.isDefined) {
							// entity is updated
							val oldVM = oldVMO.get
							val oldT = oldVM.manyToMany(column)
							val newT = newVM.manyToMany(column)
							// we'll find what was added, intersect (stayed in the collection but might have been updated)
							// and removed from the collection
							val (added, intersect, removed) = TraversableSeparation.separate(foreignEntity, oldT, newT)

							val addedCmds = added.toList.map {
								fo =>
									val foCmds = insertOrUpdate(foreignEntity, fo, updateConfig)
									val foreignVM = findVM(foCmds, fo)
									InsertManyToManyCmd(
										entity,
										foreignEntity,
										column,
										newVM,
										foreignVM) :: foCmds
							}.flatten
							val removedCms = removed.toList.map {
								fo =>
									val foreignVM = ValuesMap.fromEntity(typeManager, foreignEntity, fo)
									DeleteManyToManyCmd(
										entity,
										foreignEntity,
										column,
										oldVM,
										foreignVM
									)
							}

							val intersectCmds = intersect.toList.map {
								case (oldO, newO) =>
									val oVM = oldO match {
										case p: Persisted => p.mapperDaoValuesMap
									}
									val nVM = newO match {
										case p: Persisted => p.mapperDaoValuesMap
										case no =>
											ValuesMap.fromEntity(typeManager, foreignEntity, no)
									}
									update(foreignEntity, oVM, nVM, false, updateConfig)
							}.flatten
							addedCmds ::: removedCms ::: intersectCmds
						} else {
							// entity is new
							newVM.manyToMany(column).map {
								case p: Persisted =>
									// we need to link to the already existing foreign entity
									// and update the foreign entity
									val foreignVM = ValuesMap.fromEntity(typeManager, foreignEntity, p)
									InsertManyToManyCmd(
										entity,
										foreignEntity,
										column,
										newVM,
										foreignVM) :: doUpdate(foreignEntity, p, updateConfig)
								case o =>
									// we need to insert the foreign entity and link to entity
									val foreignVM = ValuesMap.fromEntity(typeManager, foreignEntity, o)
									InsertManyToManyCmd(
										entity,
										foreignEntity,
										column,
										newVM,
										foreignVM) :: insert(foreignEntity, foreignVM, false, updateConfig)
							}.flatten
						}
				}
		}.flatten
	}

	private def insertOrUpdate[ID, T](foreignEntity: Entity[ID, DeclaredIds[ID], T], o: T, updateConfig: UpdateConfig) = o match {
		case p: T with Persisted => doUpdate(foreignEntity, p, updateConfig)
		case _ => doInsert(foreignEntity, o, updateConfig)
	}

	private def doInsert[ID, T](foreignEntity: Entity[ID, DeclaredIds[ID], T], o: T, updateConfig: UpdateConfig) = {
		val newVM = ValuesMap.fromEntity(typeManager, foreignEntity, o)
		insert(foreignEntity, newVM, false, updateConfig)
	}

	private def doUpdate[ID, T](foreignEntity: Entity[ID, DeclaredIds[ID], T], p: T with Persisted, updateConfig: UpdateConfig) = {
		val newVM = ValuesMap.fromEntity(typeManager, foreignEntity, p)
		update(foreignEntity, p.mapperDaoValuesMap, newVM, false, updateConfig)
	}

	def findVM(cmds: List[PersistCmd], fo: Any) = cmds.head match {
		case wvm: CmdWithNewVM => val vm = wvm.newVM
		if (vm.identity != System.identityHashCode(fo)) throw new IllegalStateException("didn't find correct VM for " + fo)
		vm
	}
}