package com.googlecode.mapperdao

import com.googlecode.mapperdao.events.Events

/**
 * The MapperDao is the central trait that allows CRUD operations on entities.
 *
 * insert, update, delete and select's can be performed and all these methods
 * require the entity as a parameter and optionally a configuration for the
 * operation..
 *
 * @author kostantinos.kougios
 */
trait MapperDao {

	/**
	 * insert an entity into the database. The entity and all related non-persisted entities
	 * will be inserted into the database. All related persisted entities will be updated
	 * if their state changed.
	 *
	 * @param	entity		the entity, i.e. ProductEntity
	 * @param	o			the value, i.e. a Product
	 * @return	T with PC, i.e. Product with IntId which contains any autogenerated keys.
	 */
	def insert[PC, T](entity: Entity[PC, T], o: T): T with PC = insert(defaultUpdateConfig, entity, o)
	/**
	 * Will insert the entity into the database and will use the UpdateConfig to decide
	 * which related entities will be inserted, deleted etc.
	 *
	 * @see 	#UpdateConfig for configuration documentation.
	 * @see		#insert(entity,o)
	 */
	def insert[PC, T](updateConfig: UpdateConfig, entity: Entity[PC, T], o: T): T with PC

	/**
	 * updates a mutable entity. Non-persisted related entities will be inserted and persisted
	 * related entities will be updated (if their state changed).
	 *
	 * @param	entity	The entity, i.e. ProductEntity
	 * @param	o		the modified value, T with PC (persisted). I.e. Product with IntId
	 *
	 * @return	the updated entity, matching o, with type T with PC (hence it will include
	 * 			any autogenerated primary keys). I.e. Product with IntId which is equal to o
	 */
	def update[PC, T](entity: Entity[PC, T], o: T with PC): T with PC = update(defaultUpdateConfig, entity, o)

	/**
	 * configurable update of a mutable entity
	 *
	 * @see 	#UpdateConfig for configuration documentation.
	 * @see		#update(entity,o)
	 */
	def update[PC, T](updateConfig: UpdateConfig, entity: Entity[PC, T], o: T with PC): T with PC

	/**
	 * update of an immutable entity.
	 *
	 * @param	entity	The entity, i.e. ProductEntity
	 * @param	o		the old value, T with PC (persisted). I.e. Product with IntId
	 * @param	newO	the new value, T. I.e. Product
	 *
	 * @return	the updated entity, matching T but with type T with PC (hence it will include
	 * 			any autogenerated primary keys). I.e. Product with IntId which is equal to newO
	 */
	def update[PC, T](entity: Entity[PC, T], o: T with PC, newO: T): T with PC = update(defaultUpdateConfig, entity, o, newO)

	/**
	 * configurable update of immutable entities. Similar to update(entity,o,newO)
	 * but updateConfig configures the update.
	 *
	 * @see 	#UpdateConfig for configuration documentation.
	 * @see		#update(entity,o,newO)
	 */
	def update[PC, T](updateConfig: UpdateConfig, entity: Entity[PC, T], o: T with PC, newO: T): T with PC

	def insertOrUpdate[PC, T](
		entity: Entity[PC, T],
		o: T,
		idO: Option[Any]): T with PC = insertOrUpdate(
		entity,
		o,
		if (idO.isDefined)
			List(idO.get)
		else Nil
	)

	def insertOrUpdate[PC, T](
		entity: Entity[PC, T],
		o: T,
		ids: List[Any]): T with PC = insertOrUpdate(defaultSelectConfig, defaultUpdateConfig, entity, o, ids)

	def insertOrUpdate[PC, T](
		selectConfig: SelectConfig,
		updateConfig: UpdateConfig,
		entity: Entity[PC, T],
		o: T,
		ids: List[Any]): T with PC

	/**
	 * select an entity by it's ID
	 *
	 * @param entity	the entity, i.e. ProductEntity
	 * @param id		the id that will be fetched
	 * @return			Option[T with PC] or None, i.e. Some(Product with IntId) if the id
	 * 					exists.
	 */
	def select[PC, T](entity: Entity[PC, T], id: Any): Option[T with PC] = select(entity, List(id))
	def select[PC, T](entity: Entity[PC, T], id1: Any, id2: Any): Option[T with PC] = select(entity, List(id1, id2))
	def select[PC, T](entity: Entity[PC, T], id1: Any, id2: Any, id3: Any): Option[T with PC] = select(entity, List(id1, id2, id3))

	/**
	 * select an entity by it's ID's
	 *
	 * @param entity	the entity, i.e. ProductEntity
	 * @param ids		a list of ids for the entity. The number of elements should match
	 * 					the number of primary keys of the entity
	 * @return			Option[T with PC] or None, i.e. Some(Product with IntId) if the id's
	 * 					exist.
	 */
	def select[PC, T](entity: Entity[PC, T], ids: List[Any]): Option[T with PC] = select(defaultSelectConfig, entity, ids)

	/**
	 * select an entity with configuration of what will be loaded, lazy loaded, caching etc..
	 * i.e.
	 * SelectConfig(skip=Set(ProductEntity.attributes)) // attributes won't be loaded
	 *
	 * @param	selectConfig	the configuration for this select
	 * @param	entity			the entity to load i.e. ProductEntity
	 * @param	id				the id of the entity
	 * @return	Option[T with PC] i.e. Some(Product with IntId)
	 *
	 * @see 	#SelectConfig for all available configuration parameters
	 */
	def select[PC, T](selectConfig: SelectConfig, entity: Entity[PC, T], id: Any): Option[T with PC] = select(selectConfig, entity, List(id))

	/**
	 * select an entity with configuration of what will be loaded, lazy loaded, caching etc..
	 * i.e.
	 * SelectConfig(skip=Set(ProductEntity.attributes)) // attributes won't be loaded
	 *
	 * @param	selectConfig	the configuration for this select
	 * @param	entity			the entity to load i.e. ProductEntity
	 * @param	ids				the ids of the entity, the size of the list should match
	 * 							the number of keys of the entity
	 * @return	Option[T with PC] i.e. Some(Product with IntId)
	 *
	 * @see 	#SelectConfig for all available configuration parameters
	 */
	def select[PC, T](selectConfig: SelectConfig, entity: Entity[PC, T], ids: List[Any]): Option[T with PC]

	// default configurations, can be overriden
	protected val defaultSelectConfig = SelectConfig.default
	protected val defaultDeleteConfig = DeleteConfig.default
	protected val defaultUpdateConfig = UpdateConfig(deleteConfig = defaultDeleteConfig)

	/**
	 * deletes an entity from the database. By default, related entities won't be deleted.
	 * It is assumed that the delete will cascade appropriatelly.
	 * Please use delete(deleteConfig, entity, o) to fine tune the operation.
	 *
	 * @param	entity		the entity to be deleted, i.e. ProductEntity
	 * @param	o			the value of the entity that will be deleted, T with PC, i.e. a Product.
	 * 						o should have been retrieved from the database.
	 * @return	the value of the entity unlinked from the database.
	 */
	def delete[PC, T](entity: Entity[PC, T], o: T with PC): T = delete(defaultDeleteConfig, entity, o)

	/**
	 * configurable delete of an entity. This allows fine tuned deletion of the entity
	 * and all related data.
	 *
	 * @param	deleteConfig	the configuration, please see #DeleteConfig
	 * @param	entity			the entity to be deleted, i.e. ProductEntity
	 * @param	o				the value of the entity that will be deleted, T with PC, i.e. a Product.
	 * 							o should have been retrieved from the database.
	 * @return	the value of the entity unlinked from the database.
	 */
	def delete[PC, T](deleteConfig: DeleteConfig, entity: Entity[PC, T], o: T with PC): T

	/**
	 * this will delete an entity based on it's id.
	 *
	 * The delete will cascade to related entities only if there are cascade constraints
	 * on the foreign keys in the database. In order to configure mapperdao to delete
	 * related entities, select() the entity first and then delete it using
	 * delete(deleteConfig, entity, o). (In any case to do the same at the database level,
	 * queries would be required in order to delete the related data)
	 */
	def delete[PC, T](entity: Entity[PC, T], id: AnyVal): Unit = delete(entity, List(id))
	def delete[PC, T](entity: Entity[PC, T], ids: List[AnyVal]): Unit

	/**
	 * ===================================================================================
	 * ID helper methods
	 * ===================================================================================
	 */
	/**
	 * get the int id of an entity. The entity must be of IntId.
	 */
	def intIdOf(o: AnyRef): Int = o match {
		case iid: IntId => iid.id
	}

	/**
	 * get the long id of an entity. The entity must be of LongId
	 */
	def longIdOf(o: AnyRef): Long = o match {
		case iid: LongId => iid.id
	}

	/**
	 * links non-persisted entities to the database provided that
	 * the entity has a correct primary key.
	 *
	 * I.e. if you are able to fully recreate the entity (including it's primary keys)
	 * say after posting a form, making sure the entity has the correct database values,
	 * then you can link it back to mapperdao via the link() method. Then the linked entity
	 * can be used for updates as if it was loaded from the database. This way a select()
	 * can be avoided.
	 *
	 * Extra care should be taken to match the linked entity with the data stored in the
	 * database, otherwise an update can corrupt the data.
	 *
	 * The linked entity and all related entities should match the data stored in the
	 * database.
	 *
	 * val dog=new Dog("Jerry")
	 * val linkedDog=dao.link(dog,5)
	 *
	 * mapperDao.update(DogEntity,linkedDog,new Dog("Updated name"))
	 */
	def link[T](entity: SimpleEntity[T], o: T): T = throw new IllegalStateException("Not supported")
	def link[T](entity: Entity[IntId, T], o: T, id: Int): T with IntId = throw new IllegalStateException("Not supported")
	def link[T](entity: Entity[LongId, T], o: T, id: Long): T with LongId = throw new IllegalStateException("Not supported")

	/**
	 * unlinks an entity from mapperdao. The entity is not tracked for changes and can't
	 * be used in updates or deletes. The extra memory used by mapperdao is released.
	 *
	 * Use this i.e. when you want to store the entity in a session.
	 */
	def unlink[PC, T](entity: Entity[PC, T], o: T): T = throw new IllegalStateException("Not supported")

	/**
	 * releases the objects used to store state for lazy loading to occur, freeing memory
	 * but lazy loaded relattionships will not be loaded
	 */
	def unlinkLazyLoadMemoryData[PC, T](entity: Entity[PC, T], o: Any) {
		val visitor = new FreeLazyLoadedEntityVisitor
		visitor.visit(entity, o)
		visitor.free(o)
	}
}
