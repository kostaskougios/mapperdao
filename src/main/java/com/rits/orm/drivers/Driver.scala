package com.rits.orm.drivers
import com.rits.orm._
import com.rits.jdbc.Jdbc
import com.rits.jdbc.JdbcMap
import com.rits.jdbc.UpdateResultWithGeneratedKeys
import com.rits.jdbc.UpdateResult
/**
 * all database drivers must implement this trait
 *
 * @author kostantinos.kougios
 *
 * 14 Jul 2011
 */
trait Driver {
	val jdbc: Jdbc
	val typeRegistry: TypeRegistry
	/**
	 * =====================================================================================
	 * utility methods
	 * =====================================================================================
	 */
	protected def escapeColumnNames(name: String): String = name

	protected[orm] def commaSeparatedListOfSimpleTypeColumns[T](separator: String, columns: List[ColumnBase]): String = columns.map(_.columnName).map(escapeColumnNames _).mkString(separator)
	protected[orm] def commaSeparatedListOfSimpleTypeColumns[T](prefix: String, separator: String, columns: List[ColumnBase]): String = columns.map(_.columnName).map(escapeColumnNames _).mkString(prefix, separator + prefix, "")

	protected[orm] def generateColumnsEqualsValueString(l: List[ColumnBase]): String =
		{
			val sb = new StringBuilder(20)
			var cnt = 0
			l.foreach { ci =>
				if (cnt > 0) sb.append(",\n") else cnt += 1
				sb append escapeColumnNames(ci.columnName) append "=?"
			}
			sb.toString
		}
	protected[orm] def generateColumnsEqualsValueString(prefix: String, separator: String, l: List[ColumnBase]): String =
		{
			val sb = new StringBuilder(20)
			var cnt = 0
			l.foreach { ci =>
				if (cnt > 0) sb.append(separator) else cnt += 1
				sb append prefix append escapeColumnNames(ci.columnName) append "=?"
			}
			sb.toString
		}

	/**
	 * =====================================================================================
	 * INSERT
	 * =====================================================================================
	 */

	/**
	 * default implementation of insert, should do for most subclasses
	 */
	def doInsert[PC, T](tpe: Type[PC, T], args: List[(ColumnBase, Any)]): UpdateResultWithGeneratedKeys =
		{
			val filteredArgs = args.filter { cv =>
				cv._1 match {
					case _: AutoGenerated => false
					case PK(_: AutoGenerated) => false
					case _ => true
				}
			}
			val sql = insertSql(tpe, filteredArgs)
			jdbc.updateGetAutoGenerated(sql, filteredArgs.map(_._2))
		}

	/**
	 * default impl of the insert statement generation
	 */
	protected def insertSql[PC, T](tpe: Type[PC, T], args: List[(ColumnBase, Any)]): String =
		{
			val sb = new StringBuilder(100, "insert into ")
			sb append tpe.table.name append "(" append commaSeparatedListOfSimpleTypeColumns(",", args.map(_._1))
			sb append ")\n"
			sb append "values(?" append (",?" * (args.size - 1)) append ")"

			sb.toString
		}

	def doInsertManyToMany[PC, T, F](tpe: Type[PC, T], manyToMany: ManyToMany[F], left: List[(ColumnBase, Any)], right: List[(ColumnBase, Any)]): Unit =
		{
			val sql = insertManyToManySql(tpe, manyToMany, left, right)
			jdbc.update(sql, left.map(_._2) ::: right.map(_._2))
		}

	protected def insertManyToManySql[PC, T, F](tpe: Type[PC, T], manyToMany: ManyToMany[F], left: List[(ColumnBase, Any)], right: List[(ColumnBase, Any)]): String =
		{
			val sb = new StringBuilder(100, "insert into ")
			val linkTable = manyToMany.linkTable
			sb append linkTable.name append "(" append commaSeparatedListOfSimpleTypeColumns(",", linkTable.left) append "," append commaSeparatedListOfSimpleTypeColumns(",", linkTable.right) append ")\n"
			sb append "values(?" append (",?" * (linkTable.left.size - 1 + linkTable.right.size)) append ")"
			sb.toString
		}
	/**
	 * =====================================================================================
	 * UPDATE
	 * =====================================================================================
	 */
	/**
	 * default implementation of update, should do for most subclasses
	 */
	def doUpdate[PC, T](tpe: Type[PC, T], args: List[(ColumnBase, Any)], pkArgs: List[(ColumnBase, Any)]): UpdateResultWithGeneratedKeys =
		{
			val sql = updateSql(tpe, args, pkArgs)
			jdbc.updateGetAutoGenerated(sql, args.map(_._2) ::: pkArgs.map(_._2))
		}
	/**
	 * default impl of the insert statement generation
	 */
	protected def updateSql[PC, T](tpe: Type[PC, T], args: List[(ColumnBase, Any)], pkArgs: List[(ColumnBase, Any)]): String =
		{
			val sb = new StringBuilder(100, "update ")
			sb append tpe.table.name append "\n"
			sb append "set " append generateColumnsEqualsValueString(args.map(_._1))
			sb append "\nwhere " append generateColumnsEqualsValueString(pkArgs.map(_._1))
			sb.toString
		}

	/**
	 * links one-to-many objects to their parent
	 */
	def doUpdateOneToManyRef[PC, T](tpe: Type[PC, T], foreignKeys: List[(ColumnBase, Any)], pkArgs: List[(ColumnBase, Any)]): UpdateResult =
		{
			val sql = updateOneToManyRefSql(tpe, foreignKeys, pkArgs)
			jdbc.update(sql, foreignKeys.map(_._2) ::: pkArgs.map(_._2))
		}

	protected def updateOneToManyRefSql[PC, T](tpe: Type[PC, T], foreignKeys: List[(ColumnBase, Any)], pkArgs: List[(ColumnBase, Any)]): String =
		{
			val sb = new StringBuilder(100, "update ")
			sb append tpe.table.name append "\n"
			sb append "set " append generateColumnsEqualsValueString(foreignKeys.map(_._1))
			sb append "\nwhere " append generateColumnsEqualsValueString(pkArgs.map(_._1))
			sb.toString
		}

	/**
	 * delete many-to-many rows from link table
	 */
	def doDeleteManyToManyRef[PC, T, PR, R](tpe: Type[PC, T], ftpe: Type[PR, R], manyToMany: ManyToMany[R], leftKeyValues: List[(ColumnBase, Any)], rightKeyValues: List[(ColumnBase, Any)]): UpdateResult =
		{
			val sql = deleteManyToManyRefSql(tpe, ftpe, manyToMany, leftKeyValues, rightKeyValues)
			jdbc.update(sql, leftKeyValues.map(_._2) ::: rightKeyValues.map(_._2))
		}
	protected def deleteManyToManyRefSql[PC, T, PR, R](tpe: Type[PC, T], ftpe: Type[PR, R], manyToMany: ManyToMany[R], leftKeyValues: List[(ColumnBase, Any)], rightKeyValues: List[(ColumnBase, Any)]): String =
		{
			val sb = new StringBuilder(100, "delete from ")
			sb append manyToMany.linkTable.name append "\nwhere "
			sb append generateColumnsEqualsValueString("", " and ", leftKeyValues.map(_._1) ::: rightKeyValues.map(_._1))
			sb.toString
		}

	/**
	 * =====================================================================================
	 * SELECT
	 * =====================================================================================
	 */
	def selectColumns[PC, T](tpe: Type[PC, T]): List[ColumnBase] = tpe.table.simpleTypeColumns ::: tpe.table.manyToOneColumns.map(_.columns).flatten
	/**
	 * default impl of select
	 */
	def doSelect[PC, T](tpe: Type[PC, T], where: List[(SimpleColumn, Any)]): List[JdbcMap] =
		{
			val sql = selectSql(tpe, where)

			// 1st step is to get the simple values
			// of this object from the database
			jdbc.queryForList(sql, where.map(_._2))
		}

	protected def selectSql[PC, T](tpe: Type[PC, T], where: List[(SimpleColumn, Any)]): String =
		{
			val columns = selectColumns(tpe)
			val sb = new StringBuilder(100, "select ")
			sb append commaSeparatedListOfSimpleTypeColumns(",", columns)
			sb append " from " append tpe.table.name
			sb append "\nwhere " append generateColumnsEqualsValueString(where.map(_._1))

			sb.toString
		}

	def doSelectManyToMany[PC, T, PF, F](tpe: Type[PC, T], ftpe: Type[PF, F], manyToMany: ManyToMany[F], leftKeyValues: List[(SimpleColumn, Any)]): List[JdbcMap] =
		{
			val sql = selectManyToManySql(tpe, ftpe, manyToMany, leftKeyValues)
			jdbc.queryForList(sql, leftKeyValues.map(_._2))
		}

	protected def selectManyToManySql[PC, T, PF, F](tpe: Type[PC, T], ftpe: Type[PF, F], manyToMany: ManyToMany[F], leftKeyValues: List[(SimpleColumn, Any)]): String =
		{
			val ftable = ftpe.table
			val columns = ftable.simpleTypeColumns
			val linkTable = manyToMany.linkTable
			val sb = new StringBuilder(100, "select ")
			sb append commaSeparatedListOfSimpleTypeColumns(",", columns) append "\nfrom " append ftpe.table.name append " f\n"
			sb append "inner join " append linkTable.name append " l on "
			var i = 0
			ftable.primaryKeys.zip(linkTable.right).foreach { z =>
				val PK(left) = z._1
				val right = z._2
				if (i > 0) sb append " and "
				sb append "f." append left.columnName append "=l." append right.name
				i += 1
			}
			sb append "\nwhere " append generateColumnsEqualsValueString("l.", " and ", leftKeyValues.map(_._1))
			sb.toString
		}
	/**
	 * =====================================================================================
	 * DELETE
	 * =====================================================================================
	 */
	def doDelete[PC, T](tpe: Type[PC, T], keyValues: List[(PK, Any)]): Unit =
		{
			val sql = deleteSql(tpe, keyValues)
			jdbc.update(sql, keyValues.map(_._2))
		}

	protected def deleteSql[PC, T](tpe: Type[PC, T], keyValues: List[(PK, Any)]): String =
		{
			val sb = new StringBuilder(100, "delete from ")
			sb append tpe.table.name append " where " append generateColumnsEqualsValueString(keyValues.map(_._1))

			sb.toString
		}

	/**
	 * =====================================================================================
	 * QUERIES
	 * =====================================================================================
	 */

	// select ... from 
	def startQuery[PC, T](aliases: QueryDao.Aliases, qe: Query.QueryEntity[PC, T], columns: List[ColumnBase]): String =
		{
			val tpe = typeRegistry.typeOf(qe.entity)
			val sb = new StringBuilder(100, "select ")
			sb append commaSeparatedListOfSimpleTypeColumns(qe.alias + ".", ",", columns)
			sb append "\nfrom " append tpe.table.name append " " append aliases(tpe.table)

			sb.toString
		}

	// creates the join for many-to-one
	def manyToOneJoin[PC, T, FPC, FT](aliases: QueryDao.Aliases, joinEntity: Entity[PC, T], foreignEntity: Entity[FPC, FT], manyToOne: ManyToOne[_]): String =
		{
			val foreignTpe = typeRegistry.typeOf(foreignEntity)
			val joinTpe = typeRegistry.typeOf(joinEntity)

			val foreignTable = foreignTpe.table
			val fAlias = aliases(foreignTable)
			val jAlias = aliases(joinTpe.table)

			val sb = new StringBuilder
			sb append "\njoin " append foreignTable.name append " " append fAlias append " on "
			(manyToOne.columns zip foreignTable.primaryKeys).foreach { t =>
				sb append jAlias append "." append t._1.columnName append " = " append fAlias append "." append t._2.columnName
			}
			sb.toString
		}

	// where clause
	def where[PC, T](aliases: QueryDao.Aliases, qe: Query.QueryEntity[PC, T]): (String, List[Any]) =
		{
			val sb = new StringBuilder(100)
			var args = List[Any]()
			if (!qe.wheres.isEmpty) {
				sb append "\nwhere"
				qe.wheres.map(_.clauses).foreach { op =>
					def inner(op: OpBase): Unit = op match {
						case o: Operation[_] =>
							val leftEntity = typeRegistry.entityOf(o.left)
							sb append " "
							val leftTpe = typeRegistry.typeOf(leftEntity)
							sb append aliases(leftTpe.table)
							sb append "." append o.left.columnName append ' ' append o.operand.sql
							sb append " ?"
							args ::= o.right
						case and: AndOp =>
							sb append " ("
							inner(and.left)
							sb append " and"
							inner(and.right)
							sb append " )"
						case and: OrOp =>
							sb append " ("
							inner(and.left)
							sb append " or"
							inner(and.right)
							sb append " )"
					}

					inner(op)
				}
			}
			(sb.toString, args.reverse)
		}
	//	protected def resolveWhereExpression(aliases: QueryDao.Aliases,sb:StringBuilder,v: Any): Unit = v match {
	//		case c: ColumnBase =>
	//			sb append aliases(leftEntity.tpe.table)
	//							sb append "." append o.left.columnName
	//		case _ => "?"
	//	}
	/**
	 * =====================================================================================
	 * standard methods
	 * =====================================================================================
	 */
	override def toString = "Driver(%s)".format(jdbc)
}